\chapter{Android y Google App Engine.}

En este capítulo vamos a explicar más detenidamente las dos principales plataformas usadas en el proyecto. En la parte móvil Android y en la parte de las aplicaciones web Google App Engine. 

\section{Android}\label{cap:android}

\subsection{Introducción.}

Android es un sistema operativo basado en Linux, libre y multiplataforma. Inicialmente empezó como un sistema operativo solo para móviles pero con el tiempo ya podemos encontrarlo en móviles, tablets, pc, neveras, relojes, cámaras de fotos y una gran cantidad de aparatos.

En el proyecto lo usaremos para diseñar y desarrollar una aplicación móvil, con la que poder firmar digitálmente un texto leido previamente mediante un lector de códigos QR.

Android es propiedad de Google actualmente y es el encargado de dar soporte y ayudar a los desarrolladores. Esta función la realiza muy bien, dando una muy buena API y una gran documentación. Podemos encontrar toda la información que podemos necesitar para desarrollar una aplicación en la siguiente web, \url{http://developer.android.com/index.html}. En la anterior web podemos encontrar la documentación de la API, consejos de diseño para que la aplicación tenga un aspecto bonito a la vez que usable, todas las novedades incluidas en las versiones nuevas del sistema operativo, etc.

\subsection{Arquitectura de la plataforma Android.}

Como hemos dicho anteriormente Android es una plataforma que engloba desde el sistema operativo, al software intermedio que comunica el sistema operativo y las aplicaciones, llamado en inglés middleware y las posibilidad de hacer funcionar las aplicaciones en la plataforma elegida, ya sea un telefono, un tablet o cualquier aparato con Android.

Para los desarrolladores Android proporciona dos kit de desarrollo, uno que usa la tecnología Java (SDK), el que hemos usado en el proyecto y otro que da la posibilidad de programar a más bajo nivel (NDK), este último desarrollado en C++.

El SDK de Android proporciona ayuda para las siguientes características, un navegador basado en WebKit, graficos optimizados en 2D, gráficos en 3D basados en OpenGL ES 1.0 con aceleración gráfica, una base de datos para almacenar datos que necesitemos, llamada SQLite, soporte para ficheros gráficos (JPG, PNG, GIF, etc), vídeo (MPEG4, H.264) y audio (MP3, AAC), telefonía GSM, tecnologías inalámbricas como son Bluetooth, 3G, Wifi, uso de la cámara, GPS, brújulas, etc. Además de todo esto, proporciona ayuda en la reutilización y remplazo de componentes, una máquina virtual optimizada para dispositivos móviles llamada Dalvik y un emulador donde poder probar la aplicación antes del lanzamiento sin tener que poseer un terminal Android. 

\begin{figure}
  \centering
    \includegraphics[scale=0.6]{./Android/imagenes/arquitecturaAndroid.jpg}
  \caption{Arquitectura de Android.}
  \label{fig:arquitecturaAndroid}
\end{figure} 

La arquitectura la podemos ver en la figura~\ref{fig:arquitecturaAndroid}. En la imagen podemos observar las cinco capas principales en las que se divide Android.
\begin{itemize}

\item \textbf{Applications:} en esta capa están todas las aplicaciones que nos proporciona el sistema operativo de base, como pueden ser la lista de contactos, un gestor de SMS, el navegador, el lanzador de aplicaciones, todas las aplicaciones de servicios de Google, como pueden ser Gmail, Google Maps, Google Calendar, Google Reader.   

\item \textbf{Application framework:} en esta capa está todo lo relacionado con los manejadores de activitys, llamadas de telefono, controladores de vistas. Es una capa que hay intermedia para manejo de hardware, con la que se pueden controlar tanto las notificaciones, como servicios que se ejucutan en segundo plano, etc. Los desarrolladores tienen el mismo acceso mediante esta capa de la API a todos los servicios que las aplicaciones nativas que proporciona el sistema el operativo. 

\item \textbf{Libraries:} como su nombre indica en esta capa están todas las librerías que el sistema operativo necesita, para manejo de archivos multimedia, manejo de gráficos 3D, renderizado web, etc.

\begin{itemize}
	\item \textbf{System C library:} una implementación del estandar C, optimizada para funcionar en sistemas móviles para las funciones del kernell de linux.
	\item \textbf{Media Libraries:} librerías basadas en PacketVideo's OpenCORE para grabación y reproducción de formatos de audio y video mas populares del momento como MP3, H.264, JPG o PNG.

	\item \textbf{Surface Manager:} librería para manejo de graficos 2D y 3D para varias aplicaciones.

	\item \textbf{LibWebCore:} motor de renderizado para navegadores embebidos de páginas web.

	\item \textbf{SGL:} motor para renderizado 2D.

	\item \textbf{3D libraries:} librería que implementa la API de OpenGL ES 1.0, que proporciona aceleración 3D por hardware si es posible o una alta optimización para renderizado por software en sistemas que no posean aceleración por hardware.

	\item \textbf{FreeType:} librería para manejo de fuentes, tanto bitmap como vectoriales.

	\item \textbf{SQLite:} librería para el manejo de la base de datos que proporciona Android.

\end{itemize}

\item \textbf{Android Runtime:} es una capa que está al mismo nivel que la capa de librerías. En esta capa se añaden muchas librerías para dotar de la mayoría de las funcionalidades que proporciona Java, también está en esta capa la máquina virtual (Dalvik) encargada de ejecutar el código Smali de los archivos DEX.

\item \textbf{Linux Kernel:} Android está basado en el kernel de Linux 2.6 y todo lo relatico a seguridad, manejo de memoria, control de procesos, pila de protocolos de red y modelo de drivers es el mismo. El kernel es el que proporciona una capa de abstracción entre el hardware y el software que usará Android.

\end{itemize}

Como ya hemos dicho antes Android corre cada aplicación en una máquina virtual, esta máquina virtual recibe el nombre de Dalvik. Dicho nombre viene de un pueblo de Islandía donde viven los familiares del creador de esta, Dan Bornstein. La máquina virtual ejecuta un byte code especial llamdo DEX (Dalvik Executable), que está especialmente diseñado y optimizado para funcionar en sistemas móviles, tablets, etc. En la figura~\ref{fig:maquinaVirtualDalvik} podemos ver todo el proceso desde la creación del archivo JAVA a la ejecución.

\begin{figure}[h]
  \centering
    \includegraphics[scale=0.8]{./Android/imagenes/maquinaVirtualDalvik.png}
  \caption{Proceso de ejecución en Android.}
  \label{fig:maquinaVirtualDalvik}
\end{figure}


Los ficheros DEX meten las cadenas duplicadas y las constantes en un mismo fichero para ahorrar espacio, normalmente los archivos DEX suelen ser más pequeños que los archivos JAR de la máquina virtual Java. Una vez instados los archivos DEX pueden ser modificados en el terminal para añadir optimizaciones, reordenado de byte en ciertos datos, quitado de clases vacias, etc. En la versión 2.2 de Android se añadió una nueva característica llamada JIT (Just-In-Time) que es compilación en tiempo real de los archivos DEX, por lo que se pueden añadir nuevas optimizaciones dependiendo de la plataforma.

Todas las aplicaciones de Android se distribuyen en unos archivos con extensión APK. Estos archivos no son más que archivos ZIP con la extensión cambiada. Todos deben tener una estructura idéntica, que se explica a continuación. Contiene diferentes carpetas en las que se incluyen ficheros de configuración, fiecheros necesarios para el funcionamiento de la aplicación y para comprobar la integridad de los mismos.

\begin{itemize}

\item \textbf{META-INF:} en un directorio que contiene tres archivos, \textit{MANIFEST.MF} que es el archivo de manifest, \textit{CERT.RSA} que es el certificado con el que está firmada la aplicación, \textit{CERT.SF} que contiene el hash en SHA-1 de todos los componentes de la aplicación, un ejemplo del archivo \textit{CERT.SF} es el siguiente:

\begin{verbatim}

Signature-Version: 1.0
Created-By: 1.0 (Android)
SHA1-Digest-Manifest: wxqnEAI0UA5nO5QJ8CGMwjkGGWE=
...
Name: res/layout/exchange_component_back_bottom.xml
SHA1-Digest: eACjMjESj7Zkf0cBFTZ0nqWrt7w=
...
Name: res/drawable-hdpi/icon.png
SHA1-Digest: DGEqylP8W0n0iV/ZzBx3MW0WGCA=
\end{verbatim}

\item \textbf{lib:} esta carpeta puede contener otras dependiendo de la plataforma para la que esté diseñada la aplicación. Si por ejemplo tiene código específicamente diseñado para x86 tendrá una carpeta llamada x86, si tiene código para MIPS una llamada mips donde se encontraría el código especialmente diseñado para esta plataforma. Puede que dicha carpeta no exista.

\item \textbf{res:} este directorio contiene todos los recursos que no tienen que ser compilados, como pueden ser imágenes, sonidos, etc.

\end{itemize}

Además de estas carpetas todos los ficheros APK incluyen estos tres archivos.

\begin{itemize}
\item \textbf{AndroidManifest.xml:} es un archivo que sirve para indicar la versión, los permisos que contiene la aplicación, las referencias a librerías, las activitys que contiene la aplicación. En el siguiente listado podemos observar un extracto de los permisos que usamos en la aplicación del proyecto.

\begin{lstlisting}[style=XML]
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_SETTINGS" />
<uses-permission android:name="android.permission.GET_ACCOUNTS" />
<uses-permission android:name="android.permission.USE_CREDENTIALS" />
<uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
\end{lstlisting}

Podemos ver que con esto garantizamos que la aplicación pueda conectarse a internet, usar la tarjeta SD y manejar las cuentas almacenadas en el móvil, como puede ser la dirección de correo usada para dar de alta el móvil en Google Play.

\item \textbf{classes.dex:} el archivo DEX donde están todas las clases precompiladas en byte code para la máquina virtual Dalvik.

\item \textbf{resources.arsc:} es un fichero que contiene los recurdos precompiados como pueden ser los XML de las interfaces de la aplicación, etc.

\end{itemize}

En la imagen~\ref{fig:estructuraAPK} se pueden observar los ficheros y las carpetas comentadas anteriormente del proyecto.

\begin{figure}[h]
  \centering
    \includegraphics[scale=0.8]{./Android/imagenes/estructuraAPK.png}
  \caption{Estructura del fichero APK del proyecto.}
  \label{fig:estructuraAPK}
\end{figure}

Toda aplicación en Android se contruye con unos componentes básicos como pueden ser activities, intents, views, services, contents providers, widgets y un largo etcétera. A continuación vamos a explicar los más importantes.

\begin{itemize}

%poner sección
\item \textbf{Activity:} una activity es la entidad más básica de una interfaz de usuario donde se puede mostrar información en Android, podemos pensar que es como una ventana de cualquier aplicación de escritorio. Cada interfaz que vemos en una aplicación de Android es una activity. Android tiene un ciclo de manejo de activitys bastante complejo, se explicará en la sección~\ref{cap:desarrolandoAndroid} donde pondremos más incapié en el desarrollo de la aplicación móvil del proyecto.

\item \textbf{Intent:} un intent es un componente practicamente imprescindible en cualquier aplicación de Android, es una forma de comunicación entre cualquier componente. Se pueden definir como mensajes o peticiones, ya que también puede comunicar aplicaciones entre sí. En el proyecto usamos intent para comunicar las activities y poder intercambiar datos entre ellas, también la usamos para abrir el lector de códigos QR que necesitamos, dentro de nuestra aplicación llamamos al intent que nos proporciona la aplicación lectora y cuando termine ella nos devuelve el valor que había en el código QR para que podamos tratarlo.

\item \textbf{View:} son los componentes básicos con los que podemos contruir las interfaces gráficas, como pueden ser botones, barras de texto, campos de texto, spinner, etc. Android pone a nuestra disposición una gran cantidad de estos elementos, y además brinda la posibilidad de crear nuevos, según los vayamos necesitando. Estos objetos normalmente se añaden a una vista y se pueden añadir, modificar o borrar en ella. Estos objetos tienen un ID único en la aplicación por el que podemos controlarlo y añadirle por ejemplo el texto si es un campo de texto o un listener si es un botón para que cuando se pulse realizar la acción que necesitemos.

\item \textbf{Services:} un servicio es un componente de Android que no tiene interfaz gráfica asociada y se ejecuta en segundo plano. Es similar a los servicios que ofrece cualquier sistema operativo. Pueden realizar cualquier acción, tanto recoger o actualizar datos, lanzar notificaciones cada cierto tiempo o mostrar activity para que el usuario introduzca algún valor que necesite.

\item \textbf{Content Provider:} es un mecanismo que posee Android para intercambiar información entre aplicaciones. Por ejemplo cuando usamos la opción de compartir en el teléfono, dentro de una aplicación, nos salen varias aplicaciones con las que podemos compartir directamente, estas son todas las aplicaciones que han implementado el content provider que necesita esta aplicación para compartir la información. En la figura~\ref{fig:contentProvider} podemos ver la opción de compartir de una aplicación y podemos observar como aparece por ejemplo GMail para mandar un email directamente desde aquí sin tener conocimiento de como se produce el intercambio de datos.
 
\begin{figure}[h]
  \centering
    \includegraphics[scale=0.2]{./Android/imagenes/contentProvider.png}
  \caption{Opción compartir de una aplicación.}
  \label{fig:contentProvider}
\end{figure}

\item \textbf{Broadcast Receiver:} es un componente de Android diseñado para actuar cuando ocurre un evento general del sistema, como puede ser la recepción de un SMS, la batería se está agotando, una llamada entrante, etc. También una aplicación puede generar eventos de este tipo para que cualquiera que implemente un Broadcast Receiver pueda recibirlo.

\item \textbf{Widget:} son elementos visuales y generalmente para que el usuario realice alguna acción, tales como poner en pausa la música, pasar de canción, revisar los feed RSS, mirar los correos pendientes, etc. Suele estar en alguna de las pantallas principales de Android. En la figura~\ref{fig:widget} podemos ver un widget de GMail.
 
\begin{figure}[h]
  \centering
    \includegraphics[scale=0.2]{./Android/imagenes/widget.png}
  \caption{Widget de GMail.}
  \label{fig:widget}
\end{figure}

\subsection{Desarrollando en Android.}\label{cap:desarrolandoAndroid}

Como ya hemos dicho anteriormente para el desarrollo de la aplicación móvil hemos usado el IDE de programación Eclipse. En el anexo~\ref{cap:apendiceA} podemos ver como realizar la configuración de Eclipse para la programación de aplicaciones Android. En la sección~\ref{cap:proyectoBasico} se explicará con más detenimiento la estructura de un proyecto básico en Android.

En este apartado vamos a explicar las entidades más importantes que existen en Android, como pueden ser las activity, fragment, y view usados en el proyecto.

En el proyecto la entidad más importante que hemos usado es la \lstinline{Activity}. Normalmente las activity están enfocadas a interactuar con el usuario de alguna forma, ya puede ser necesitando de alguna acción del usuario o mostrando información y normalmente ocupan toda la pantalla del terminal, pero puede flotar dentro de otra activity o agruparse con otras usando la clase \lstinline{ActivityGroup}. Todas las subclases que hereden de \lstinline{Activity} tienen que implementar dos métodos impresindibles. Estos son \lstinline{onCreate(Bundle)} y \lstinline{onPause()}. El primero es donde se inicializa la activity y en el segundo es lo que ocurre cuando el usuario abandona la activity.

Habitualmente toda Activity tiene asociada una interfáz gráfica que se diseña en un fichero XML, como veremos posteriormente, este archivo se le indica a cada Activity con el método \lstinline{setContentView(int);} al cual hay que pasarle una constante que genera automáticamente la clase \lstinline{R} de Android. Una vez se le ha indicado el archivo XML se puede obtener cada uno de los componentes (botones, cuadros de texto, etc) que componen la intefaz gráfica con el método \lstinline{findViewById(int)}. Todo este proceso se tiene que realizar dentro del método \lstinline{onCreate();} y se puede observar en el siguiente trozo de código.

\begin{lstlisting}[style=Java]
@Override
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setContentView(R.layout.initialconfigurescreen);

	TextView tAccountOk = (TextView) findViewById(R.id.tAccountOk);
	EditText tCertificate = (EditText) findViewById(R.id.tCertificate);
	ImageView image = (ImageView) findViewById(R.id.imageView1);

	Button bSelectAccount = (Button) findViewById(R.id.bConfigureScreenAccount);
}
\end{lstlisting}

A continuación vamos a explicar las características y su ciclo de vida de las Activity, ya que es un tema muy importante cuando desarrollamos una aplicación Android. En la figura~\ref{fig:cicloActivity} podemos ver todos los estados por los que pasa una Activity desde que se crea hasta que finaliza. 

\begin{figure}
  \centering
    \includegraphics[scale=0.8]{./Android/imagenes/cicloActivity.png}
  \caption{Ciclo de vida de una activity.}
  \label{fig:cicloActivity}
\end{figure}

Todos estos estados se pueden controlar mediante la implementación en la clase que hereda de \lstinline{Activity} de los siguientes métodos.

\begin{lstlisting}[style=Java]
public class Activity extends ApplicationContext {
	protected void onCreate(Bundle savedInstanceState);

	protected void onStart();

	protected void onRestart();

	protected void onResume();

	protected void onPause();

	protected void onStop();

	protected void onDestroy();
}
\end{lstlisting}

Como podemos ver en la figura \ref{fig:cicloActivity} podemos ver que el ciclo completo de una activity es desde el método \lstinline{onCreate(Bundle);} hasta que se realiza la llamada al método \lstinline{onDestroy();}. Como hemos visto antes en \lstinline{onCreate(Bundle);} se genera todo lo necesario para que la activity funcione, como puede ser la inicialización de la interfaz, la creación de un hilo para que realice una operación en background o cualquier otra acción que necesite ser inicializada. El método \lstinline{onDestroy();} se pararía el hilo y se liberá la memoria usada por la activity. Entre los procesos \lstinline{onStart();} y \lstinline{onStop();} es donde se mantienen los recursos para que la activity pueda mostrar los datos al usuario. Por ejemplo si tenemos un \lstinline{BroadcastReceiver}, que nos puede cambiar la interfaz de usuario pues lo registramos en el método \lstinline{onStart();} y lo paramos en \lstinline{onStop();}. Estos dos métodos se llaman mucho a lo largo de la ejecución de la activity cada vez que el usuario oculta la activity y vuelve a ejecutarla. Los métodos \lstinline{onResume();} y \lstinline{onPause();} se usan para intercambio de activity, cuando apagamos la pantalla del móvil y volvemos a encenderla, cuando giramos la pantalla, etc. En estos métodos se suelen usar \lstinline{Bundle} para intercambiar información entre los estados y así conseguir por ejemplo restaurar el texto de un cuadros de texto cuando vuelve a generarse.

En esta tabla podemos observar en cada estado del ciclo de vida de una activity puede ser matada y cual sería el próximo estado.
\begin{center}
\begin{tabular}{|l | c | r|}

\hline
Method & ¿Terminable? & Proximo estado\\
\hline
onCreate() & No & onStart()\\
\hline
onRestart() & No & onStart()\\
\hline
onStart() & No & onResume() o onStop()\\
\hline
onResume() & No & onPause()\\
\hline
onPause() & No  & onResume() o onStop()\\
\hline
onStop() & Sí & onRestart() o onDestroy()\\
\hline
onDestroy() & Sí & Ninguna\\
\hline

\end{tabular}
\end{center}

Antes de la versión 3.0 de Android las activity tenian que ocupar toda la ventana y para cambiar o mostrar otra pantalla había que generar una nueva activity de la siguiente forma:

\begin{lstlisting}[style=Java]
Intent intent = new Intent(activity, SplashScreenActivity.class);
startActivity(intent);
\end{lstlisting}

Ese trozo de código se ejecuta en una activity y podemos ver que se crea un objetos \lstinline{Intent} al cual se le dice la activity en la que está y la activity que tiene que iniciar, en este caso la variable \lstinline{activity} es la actual, y \lstinline{SplashScreenActivity} es una activity que tiene la función de inciar todas las variables y realizar las conexiones básicas en el proyecto, acto seguido se usa el procedimiento \lstinline{startActivity(intent);} al que se le pasa el objeto \lstinline{Intent} creado anteriormente y con esto tendríamos la nueva activity ejecutándose.

Desde la versión 3.0 y posteriores las activity siguen ocupando toda la pantalla pero se dio la posibilidad al programador de que usara solo trozos de ella con una clase llamada \lstinline{Fragment} de esta forma no tendría que iniciar una nueva activity cada vez que quiera modificar la interfáz, de este modo se pudieron empezar a usar gestos de scroll laterar para mostrar varias interfaces o en pantallas grandes como una tablet poder modificarla sin tener que generar una nueva activity. 
\begin{figure}
  \centering
    \includegraphics[scale=0.3]{./Android/imagenes/gmailTablet.png}
  \caption{Aplicación de Gmail para tablet.}
  \label{fig:gmailTablet}
\end{figure}

\begin{figure}
  \centering
    \includegraphics[scale=0.4]{./Android/imagenes/gmailMovil.png}
  \caption{Aplicación de Gmail para móvil.}
  \label{fig:gmailMovil}
\end{figure}

\begin{figure}[h]
  \centering
    \includegraphics[scale=0.2]{./Android/imagenes/swype.png}
  \caption{Gesto Swype en la aplicación móvil.}
  \label{fig:swype}
\end{figure}

En la imagen~\ref{fig:gmailTablet} podemos ver la aplicación de Gmail diseñada mediante fragment y en ella si pulsamos algún correo en la parte izquierda de la aplicación nos mostraría el correo en la derecha sin tener que recagar la aplicación. En la imagen~\ref{fig:gmailMovil} podemos ver como en la versión movil no se usa esta forma por falta de espacio en la pantalla. Nosotros hemos realizado un diseño para intercambio de fragment mediante un gesto llamado swype o scroll lateral y como se puede ver en la imagen~\ref{fig:swype} podemos ver que no hay que volver a cargar otra activity ni nada, por lo que dotamos a la aplicación de una mayor fluidés.

Para que una aplicación pueda usar una determinada activity, el programador primeramente tiene que definir el uso y su función en el archivo \textit{AndroidManifest.xml}. Podemos ver un extracto de dicho archivo donde definimos un par de activity usadas en el proyecto.
\newpage
\begin{lstlisting}[style=XML]
<activity android:name=".FirmaDigitalUMA_ICSActivity" />
<activity android:name=".InitialConfiguration" android:noHistory="true" />
\end{lstlisting}

Se puede observar que hemos declarado dos activities una sin ninguna opción y otra en la que no se guardará en la pila de llamadas de activity, por lo que si pulsamos el botón atrás no se abrirá de nuevo. Si no realizamos este proceso nos dará un error en tiempo de ejución la aplicación diciendo que hemos intentado ejecutar una activity que no está declarada.

\subsection{Un Proyecto básico de Android en Eclipse.}\label{cap:proyectoBasico}

A continuación vamos explicar con más detenimiento la estructura que tiene un proyecto básico de Android en Eclipse.

\begin{figure}
  \centering
    \includegraphics[scale=1]{./Android/imagenes/estructuraBasicaAndroid.png}
  \caption{Estructura básica de un proyecto Android.}
  \label{fig:estructuraBasicaAndroid}
\end{figure}

En la figura~\ref{fig:estructuraBasicaAndroid} podemos ver una captura de un proyecto recien creado. Podemos observar que se genera una carpeta principal en la que posteriormente colgarán el resto de carpetas necesarias. Estas carpetas son \textit{src}, \textit{gen}, \textit{assets}, \textit{bin}, \textit{res} y varios archivos sueltos como con \textit{AndroidManifest.xml}, \textit{proguard-project.txt}, \textit{project.properties}, vamos a explicar brevemente que contiene y cual es la función de dichas carpetas y documentos.

\begin{itemize}

\item \textbf{src:} en esta carpeta están todos los paquetes que contiene los archivos de código fuente que se necesitan en el proyecto.

\item \textbf{gen:} esta carpeta es donde se almacena todo lo que el proyecto de Android necesita para funcionar, casi todos los ficheros que se encuentran en el interior se generan cada vez que se construye el proyecto y si los modificamos nosotros, cuando volvamos a construir el proyecto borrarán los cambios. Dentro está la clase \lstinline{R} donde se declaran la mayoría de las constantes con direcciones de memoria que luego en tiempo de ejecución se usarán para realizar la conversión en bytecode del archivo java.

\item \textbf{bin:} es una carpeta donde se almacenan todos los archivos binarios, como puede ser el archivo APK, los archivos DEX, etc.

\item \textbf{res:} esta carpeta la encargada de contener todos los recursos necesarios para nuestra aplicación. Esta carpeta se divide en varias, como por ejemplo \textit{drawable-hdpi}, \textit{drawable-ldpi}, \textit{drawable-mdpi}, \textit{drawable-xhdpi} es donde se añaden todas imágenes usadas, sonidos, videos, etc. Pero no todos los recursos son contenido multimedia, hay otras carpetas como por ejemplo la carpeta \textit{layout} donde se almacenan las diferentes interfaces usadas en el en formato XML o la carpeta \textit{values} donde se guardan todas las cadenas constantes en un archivo XML.

\item \textbf{AndroidManifest.xml:} como ya hemos explicado anteriormente es el archivo donde se declara todos los permisos e información de interes de la aplicación, como pueden ser las activity, los intent, la versión mínima que tiene que tener el móvil para ejecutar nuestra aplicación, etc.  

\item \textbf{project.properties:} es un archivo donde se pueden configurar diferentes parámetros del proyecto, como puede ser la API sobre la que se va a ejecutar el proyecto, o si queremos usar una herramienta que ofrece Google dentro del SDK para ofuscar el código llamada ProGuard.

\item \textbf{proguard-project.txt:} ProGuard como hemos dicho antes es una herramienta que ofrece Google dentro del SDK de Android para ofuscación de código, ya que hay muchas herramientas de ingeniería inversa que mediante la decompilación de los archivos DEX se puede llegar casi a conseguir el código realizado sin permiso. En este archivo se puede configurar los diferentes valores para el uso de esta herramienta, tales como son que tipo de ofuscación queremos utilizar si solo sintáctica o semántica, si queremos que se pueda tracear la salida del archivo, etc. Para amplicar conocimientos sobre dicha herramienta podemos visitar esta web, \url{http://developer.android.com/tools/help/proguard.html} donde está toda la información necesaria.

\end{itemize}

















